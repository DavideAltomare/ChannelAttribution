
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ChannelAttribution &#8212; ChannelAttribution 2.1.4 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ChannelAttribution 2.1.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ChannelAttribution</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ChannelAttribution</h1><div class="highlight"><pre>
<span></span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">**Markov Model for Online Multi-Channel Attribution**</span>
<span class="sd">Advertisers use a variety of online marketing channels to reach consumers and they want to know the degree each channel contributes to their marketing success. This is called online multichannel attribution problem. In many cases, advertisers approach this problem through some simple heuristics methods that do not take into account any customer interactions and often tend to underestimate the importance of small channels in marketing contribution. This package provides a function that approaches the attribution problem in a probabilistic way. It uses a k-order Markov representation to identify structural correlations in the customer journey data. This would allow advertisers to give a more reliable assessment of the marketing contribution of each channel. The approach basically follows the one presented in Eva Anderl, Ingo Becker, Florian v. Wangenheim,</span>
<span class="sd">Jan H. Schumann (2014). Differently from them, we solved the estimation process using stochastic simulations. In this way it is also possible to take into account conversion values and their variability in the computation of the channel importance. The package also contains a function that estimates three heuristic models (first-touch, last-touch and linear-touch approach) for the same problem.</span>


<span class="sd">&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="heuristic_models"><a class="viewcode-back" href="../index.html#ChannelAttribution.heuristic_models">[docs]</a><span class="k">def</span> <span class="nf">heuristic_models</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span><span class="n">var_path</span><span class="p">,</span><span class="n">var_conv</span><span class="p">,</span><span class="n">var_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">flg_adv</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            </span>
<span class="sd">    Estimate three heuristic models (first-touch, last-touch and linear) from customer journey data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Data : DataFrame</span>
<span class="sd">        customer journeys.</span>
<span class="sd">    var_path: string</span>
<span class="sd">        column of Data containing paths.</span>
<span class="sd">    var_conv : string</span>
<span class="sd">        column of Data containing total conversions for each path.</span>
<span class="sd">    var_value : string, optional, default None</span>
<span class="sd">        column of Data containing revenue for each path.</span>
<span class="sd">    sep : string, default &quot;&gt;&quot;</span>
<span class="sd">        separator between the channels.</span>
<span class="sd">    flg_adv : bool, default True</span>
<span class="sd">        if True, ChannelAttribution Pro banner is printed.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataFrame        </span>
<span class="sd">        (column) channel_name : channel names</span>
<span class="sd">        (column) first_touch_conversions : conversions attributed to each channel using first touch attribution.</span>
<span class="sd">        (column) first_touch_value : revenues attributed to each channel using first touch attribution.</span>
<span class="sd">        (column) last_touch_conversions : conversions attributed to each channel using last touch attribution.</span>
<span class="sd">        (column) last_touch_value : revenues attributed to each channel using last touch attribution.</span>
<span class="sd">        (column) linear_touch_conversions : conversions attributed to each channel using linear attribution.</span>
<span class="sd">        (column) linear_touch_value : revenues attributed to each channel using linear attribution.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Load Data</span>

<span class="sd">    &gt;&gt;&gt; import pandas as pd    </span>
<span class="sd">    &gt;&gt;&gt; from ChannelAttribution import *</span>
<span class="sd">    &gt;&gt;&gt; Data = pd.read_csv(&#39;https://channelattribution.io/csv/Data.csv&#39;,sep=&quot;;&quot;)</span>
<span class="sd">        </span>
<span class="sd">    Estimate heuristic models on total conversions</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; heuristic_models(Data,&quot;path&quot;,&quot;total_conversions&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Estimate heuristic models on total conversions and total revenues</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; heuristic_models(Data,&quot;path&quot;,&quot;total_conversions&quot;,\\</span>
<span class="sd">    &gt;&gt;&gt; var_value=&quot;total_conversion_value&quot;)</span>
<span class="sd">     </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;DataFrame&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Data</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Data must be a DataFrame&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">var_path</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">var_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a column of Data&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a string&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">var_conv</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_conv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a column of Data&quot;</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a string&quot;</span><span class="p">)</span>
   
    <span class="k">if</span> <span class="p">(</span><span class="n">var_value</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_value must be a column of Data&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;sep must have length 1&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">var_value</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vv</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_value</span><span class="p">]</span>


    <span class="n">res0</span><span class="o">=</span><span class="n">__heuristic_models_1</span><span class="p">(</span><span class="n">Data</span><span class="p">[</span><span class="n">var_path</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="n">Data</span><span class="p">[</span><span class="n">var_conv</span><span class="p">],</span><span class="n">vv</span><span class="p">,</span><span class="n">sep</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
    
        <span class="n">res</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_name&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;first_touch&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;last_touch&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;linear_touch&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]})</span>
    
    <span class="k">else</span><span class="p">:</span>
    
        <span class="n">res</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_name&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;first_touch_conversions&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;first_touch_value&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;last_touch_conversions&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;last_touch_value&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;linear_touch_conversions&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;linear_touch_value&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">5</span><span class="p">]})</span>
    
    <span class="k">if</span> <span class="n">flg_adv</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** Looking to run more advanced attribution? Try ChannelAttribution Pro for free! Visit https://channelattribution.io/product&quot;</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="choose_order"><a class="viewcode-back" href="../index.html#ChannelAttribution.choose_order">[docs]</a><span class="k">def</span> <span class="nf">choose_order</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span><span class="n">var_path</span><span class="p">,</span><span class="n">var_conv</span><span class="p">,</span><span class="n">var_null</span><span class="p">,</span><span class="n">max_order</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span><span class="n">ncore</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">roc_npt</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flg_adv</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    Find the minimum Markov Model order that gives a good representation of customersâ€™ behaviour for data considered. It requires paths that do not lead to conversion as input. Minimum order is found maximizing a penalized area under ROC curve.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Data : DataFrame</span>
<span class="sd">        customer journeys.</span>
<span class="sd">    var_path: string</span>
<span class="sd">        column of Data containing paths.</span>
<span class="sd">    var_conv : string</span>
<span class="sd">        column of Data containing total conversions for each path.</span>
<span class="sd">    var_null : string</span>
<span class="sd">        column of Data containing total paths that do not lead to conversion.</span>
<span class="sd">    max_order : int, default 10</span>
<span class="sd">        maximum Markov Model order to be considered.        </span>
<span class="sd">    sep : string, default &quot;&gt;&quot;</span>
<span class="sd">        separator between the channels.    </span>
<span class="sd">    ncore : int, default 1</span>
<span class="sd">        number of threads to be used in computation.        </span>
<span class="sd">    roc_npt: int, default 100</span>
<span class="sd">        number of points to be used for the approximation of roc curve.    </span>
<span class="sd">    plot: bool, default True</span>
<span class="sd">        if True, a plot with penalized auc with respect to order will be displayed.</span>
<span class="sd">    flg_adv : bool, default True</span>
<span class="sd">        if True, ChannelAttribution Pro banner is printed.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list        </span>
<span class="sd">        roc : list DataFrame one for each order considered</span>
<span class="sd">            (column) tpr: true positive rate</span>
<span class="sd">            (column) fpr: false positive rate</span>
<span class="sd">        auc : DataFrame with the following columns</span>
<span class="sd">            (column) order: markov model order  </span>
<span class="sd">            (column) auc: area under the curve</span>
<span class="sd">            (column) pauc: penalized auc</span>
<span class="sd">        suggested order : int</span>
<span class="sd">            estimated best order </span>
<span class="sd">            </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Estimate best makov model order for your data</span>
<span class="sd">    </span>
<span class="sd">    Load Data</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd    </span>
<span class="sd">    &gt;&gt;&gt; from ChannelAttribution import *</span>
<span class="sd">    &gt;&gt;&gt; Data = pd.read_csv(&#39;https://channelattribution.io/csv/Data.csv&#39;,sep=&quot;;&quot;)</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; choose_order(Data, var_path=&quot;path&quot;, var_conv=&quot;total_conversions&quot;, var_null=&quot;total_null&quot;)</span>


<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;DataFrame&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Data</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Data must be a DataFrame&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">var_path</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">var_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a column of Data&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a string&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">var_conv</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_conv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a column of Data&quot;</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a string&quot;</span><span class="p">)</span>
   
        
    <span class="k">if</span> <span class="p">(</span><span class="n">var_null</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_null</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_null must be a column of Data&quot;</span><span class="p">)</span>
      
    <span class="k">if</span> <span class="p">(</span><span class="n">max_order</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;max_order must be &gt;= 1&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">ncore</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ncore</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;ncore must be &gt;= 1&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="p">(</span><span class="n">roc_npt</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">roc_npt</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;roc_npt must be &gt;= 10&quot;</span><span class="p">)</span>
        
    
    <span class="k">if</span> <span class="p">(</span><span class="n">plot</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;plot must be False or True&quot;</span><span class="p">)</span>
    
    <span class="n">res0</span><span class="o">=</span><span class="n">__choose_order_1</span><span class="p">(</span><span class="n">vy</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_path</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="n">vc</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_conv</span><span class="p">],</span><span class="n">vn</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_null</span><span class="p">],</span> <span class="n">max_order</span><span class="o">=</span><span class="n">max_order</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="n">ncore</span><span class="o">=</span><span class="n">ncore</span><span class="p">,</span> <span class="n">roc_npt</span><span class="o">=</span><span class="n">roc_npt</span><span class="p">)</span>    

    <span class="n">order</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">auc</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">pauc</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
 
    <span class="n">max_order_0</span><span class="o">=</span><span class="n">order</span><span class="p">[</span><span class="n">order</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">best_order</span><span class="o">=</span><span class="n">res0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
   
    <span class="n">best_order</span><span class="o">=</span><span class="n">best_order</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">best_order</span><span class="o">==</span><span class="n">max_order_0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Suggested order not found. Try increasing max_order.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Suggested order: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">best_order</span><span class="p">)))</span>

    <span class="n">auc</span><span class="o">=</span><span class="n">auc</span><span class="p">[</span><span class="n">order</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pauc</span><span class="o">=</span><span class="n">pauc</span><span class="p">[</span><span class="n">order</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">[</span><span class="n">order</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="o">==</span><span class="s2">&quot;True&quot;</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;PENALIZED AUC&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;order&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;penalized auc&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">pauc</span><span class="p">)</span> 
    
    <span class="n">auc</span><span class="o">=</span><span class="n">auc</span><span class="p">[</span><span class="n">order</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">best_order</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">pauc</span><span class="o">=</span><span class="n">pauc</span><span class="p">[</span><span class="n">order</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">best_order</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">[</span><span class="n">order</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">best_order</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    
    <span class="n">res_auc</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;order&#39;</span><span class="p">:</span><span class="n">order</span><span class="p">,</span><span class="s1">&#39;auc&#39;</span><span class="p">:</span><span class="n">auc</span><span class="p">,</span><span class="s1">&#39;pauc&#39;</span><span class="p">:</span><span class="n">pauc</span><span class="p">})</span>
    
    <span class="n">res_roc</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">best_order</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">res_roc</span><span class="p">[</span><span class="s1">&#39;order=&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;fpr&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">],</span><span class="s1">&#39;tpr&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]})</span>
    
    <span class="k">if</span> <span class="n">flg_adv</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** Looking to run more advanced attribution? Try ChannelAttribution Pro for free! Visit https://channelattribution.io/product&quot;</span><span class="p">)</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">res_auc</span><span class="p">,</span><span class="n">res_roc</span><span class="p">,</span><span class="n">best_order</span><span class="p">)</span></div>
            
    
        
<div class="viewcode-block" id="markov_model"><a class="viewcode-back" href="../index.html#ChannelAttribution.markov_model">[docs]</a><span class="k">def</span> <span class="nf">markov_model</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span><span class="n">var_path</span><span class="p">,</span><span class="n">var_conv</span><span class="p">,</span><span class="n">var_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">var_null</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nsim_start</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span><span class="n">max_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">out_more</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span><span class="n">ncore</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">conv_par</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span><span class="n">rate_step_sim</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flg_adv</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    </span>
<span class="sd">    Estimate a k-order Markov model from customer journey data. Differently from markov_model, this function iterates estimation until a desidered convergence is reached and enables multiprocessing.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Data : DataFrame</span>
<span class="sd">        customer journeys.</span>
<span class="sd">    var_path: string</span>
<span class="sd">        column of Data containing paths.</span>
<span class="sd">    var_conv : string</span>
<span class="sd">        column of Data containing total conversions for each path.</span>
<span class="sd">    var_value : string, optional, default None</span>
<span class="sd">        column of Data containing revenue for each path.</span>
<span class="sd">    var_null : string</span>
<span class="sd">        column of Data containing total paths that do not lead to conversion.</span>
<span class="sd">    order : int, default 1</span>
<span class="sd">        Markov model order.        </span>
<span class="sd">    nsim_start : int, default 1e5</span>
<span class="sd">        minimum number of simulations to be used in computation.        </span>
<span class="sd">    max_step : int, default None</span>
<span class="sd">        maximum number of steps for a single simulated path. if NULL, it is the maximum number of steps found into Data.        </span>
<span class="sd">    out_more : bool, default False</span>
<span class="sd">        if True, transition probabilities between channels and removal effects will be returned.                </span>
<span class="sd">    sep : string, default &quot;&gt;&quot;</span>
<span class="sd">        separator between the channels.    </span>
<span class="sd">    ncore : int, default 1</span>
<span class="sd">        number of threads to be used in computation.        </span>
<span class="sd">    nfold : int, default 10</span>
<span class="sd">        how many repetitions to be used to verify if convergence has been reached at each iteration.    </span>
<span class="sd">    seed : int, default 0</span>
<span class="sd">        random seed. Giving this parameter the same value over different runs guarantees that results will not vary.    </span>
<span class="sd">    conv_par : double, default 0.05</span>
<span class="sd">        convergence parameter for the algorithm. The estimation process ends when the percentage of variation of the results over different repetions is less than convergence parameter.    </span>
<span class="sd">    rate_step_sim : double, default 0</span>
<span class="sd">        number of simulations used at each iteration is equal to the number of simulations used at previous iteration multiplied by rate_step_sim.    </span>
<span class="sd">    verbose : bool, default True</span>
<span class="sd">        if True, additional information about process convergence will be shown.    </span>
<span class="sd">    flg_adv : bool, default True</span>
<span class="sd">        if True, ChannelAttribution Pro banner is printed.</span>
<span class="sd">            </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of DataFrames</span>
<span class="sd">        result: Dataframe</span>
<span class="sd">            (column) channel_name : channel names</span>
<span class="sd">            (column) total_conversions : conversions attributed to each channel</span>
<span class="sd">            (column) total_conversion_value : revenues attributed to each channel</span>
<span class="sd">        transition_matrix : DataFrame</span>
<span class="sd">            (column) channel_from: channel from</span>
<span class="sd">            (column) channel_to : channel to</span>
<span class="sd">            (column) transition_probability : transition probability from channel_from to channel_to</span>
<span class="sd">        removal_effects:</span>
<span class="sd">            (column) channel_name : channel names </span>
<span class="sd">            (column) removal_effects_conversion : removal effects for each channel calculated using total conversions</span>
<span class="sd">            (column) removal_effects_conversion_value : removal effects for each channel calculated using revenues</span>
<span class="sd">                </span>
<span class="sd">                        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Load Data</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd    </span>
<span class="sd">    &gt;&gt;&gt; from ChannelAttribution import *</span>
<span class="sd">    &gt;&gt;&gt; Data = pd.read_csv(&#39;https://channelattribution.io/csv/Data.csv&#39;,sep=&quot;;&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Estimate a Makov model using total conversions </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; markov_model(Data, &quot;path&quot;, &quot;total_conversions&quot;)</span>

<span class="sd">    Estimate a Makov model using total conversions and revenues </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; markov_model(Data, &quot;path&quot;, &quot;total_conversions&quot;, var_value=&quot;total_conversion_value&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Estimate a Makov model using total conversions, revenues and paths that do not lead to conversions </span>

<span class="sd">    &gt;&gt;&gt; markov_model(Data, &quot;path&quot;, &quot;total_conversions&quot;, var_value=&quot;total_conversion_value&quot;, var_null=&quot;total_null&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Estimate a Makov model returning transition matrix and removal effects </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; markov_model(Data, &quot;path&quot;, &quot;total_conversions&quot;, var_value=&quot;total_conversion_value&quot;, var_null=&quot;total_null&quot;, out_more=True)</span>

<span class="sd">    Estimate a Markov model using 4 threads</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; markov_model(Data, &quot;path&quot;, &quot;total_conversions&quot;, var_value=&quot;total_conversion_value&quot;, ncore=4)</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;DataFrame&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Data</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Data must be a DataFrame&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">var_path</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">var_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a column of Data&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a string&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">var_conv</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_conv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a column of Data&quot;</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a string&quot;</span><span class="p">)</span>
   
    <span class="k">if</span> <span class="p">(</span><span class="n">var_value</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_value must be a column of Data&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">var_null</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_null</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_null must be a column of Data&quot;</span><span class="p">)</span>
      
    <span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;order must be &gt;= 1&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">nsim_start</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsim_start</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;nsim must be &gt;= 1&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">max_step</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_step</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;max_step must be &gt;= 1&quot;</span><span class="p">)</span>
        
    
    <span class="k">if</span> <span class="p">(</span><span class="n">out_more</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;out_more must be False or True&quot;</span><span class="p">)</span>
    
        
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;sep must have length 1&quot;</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="p">(</span><span class="n">ncore</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;ncore must be &gt;= 1&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">nfold</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;nfold must be &gt;= 1&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">seed</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">seed</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;seed must be &gt;= 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">conv_par</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">conv_par</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;conv_par must be into [0,1]&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">rate_step_sim</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;rate_step_sim must be &gt; 0&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span> 
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;verbose must be False or True&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Data</span><span class="p">[</span><span class="n">var_conv</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Data must have at least one converting path.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">var_null</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">Data</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">Data</span><span class="p">[</span><span class="n">var_conv</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>    
    
    <span class="k">if</span> <span class="p">(</span><span class="n">var_value</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vv</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_value</span><span class="p">]</span>
    

    <span class="k">if</span> <span class="p">(</span><span class="n">var_null</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vn</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_null</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">max_step</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">max_step</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">res0</span><span class="o">=</span><span class="n">__markov_model_1</span><span class="p">(</span><span class="n">vy</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_path</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="n">vc</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_conv</span><span class="p">],</span><span class="n">vv</span><span class="o">=</span><span class="n">vv</span><span class="p">,</span><span class="n">vn</span><span class="o">=</span><span class="n">vn</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span><span class="n">nsim_start</span><span class="o">=</span><span class="n">nsim_start</span><span class="p">,</span><span class="n">max_step</span><span class="o">=</span><span class="n">max_step</span><span class="p">,</span><span class="n">out_more</span><span class="o">=</span><span class="n">out_more</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">),</span><span class="n">ncore</span><span class="o">=</span><span class="n">ncore</span><span class="p">,</span> <span class="n">nfold</span><span class="o">=</span><span class="n">nfold</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">conv_par</span><span class="o">=</span><span class="n">conv_par</span><span class="p">,</span> <span class="n">rate_step_sim</span><span class="o">=</span><span class="n">rate_step_sim</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">verbose</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">out_more</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
    
        <span class="n">res</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_name&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;total_conversions&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]})</span>
    
    <span class="k">elif</span> <span class="p">(</span><span class="n">out_more</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>

        <span class="n">res</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_name&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;total_conversions&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;total_conversion_value&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]})</span>

    <span class="k">elif</span> <span class="p">(</span><span class="n">out_more</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        
        <span class="n">res</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        
        <span class="n">res</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_name&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;total_conversions&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]})</span>
        <span class="n">res</span><span class="p">[</span><span class="s1">&#39;transition_matrix&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_from&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;channel_to&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;transition_probability&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]})</span>
    
        <span class="n">res</span><span class="p">[</span><span class="s1">&#39;removal_effects&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_name&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;removal_effect&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]})</span>
    
    <span class="k">else</span><span class="p">:</span>
    
        <span class="n">res</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        
        <span class="n">res</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_name&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;total_conversions&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;total_conversion_value&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]})</span>
        <span class="n">res</span><span class="p">[</span><span class="s1">&#39;transition_matrix&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_from&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;channel_to&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;transition_probability&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]})</span>
    
        <span class="n">res</span><span class="p">[</span><span class="s1">&#39;removal_effects&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_name&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;removal_effects_conversion&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;removal_effects_conversion_value&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">]})</span>        
    
    <span class="k">if</span> <span class="n">flg_adv</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** Looking to run more advanced attribution? Try ChannelAttribution Pro for free! Visit https://channelattribution.io/product&quot;</span><span class="p">)</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="transition_matrix"><a class="viewcode-back" href="../index.html#ChannelAttribution.transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">transition_matrix</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span><span class="n">var_path</span><span class="p">,</span><span class="n">var_conv</span><span class="p">,</span><span class="n">var_null</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span><span class="n">flg_equal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flg_adv</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Estimate a k-order transition matrix from customer journey data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Data : DataFrame</span>
<span class="sd">        customer journeys.</span>
<span class="sd">    var_path: string</span>
<span class="sd">        column of Data containing paths.</span>
<span class="sd">    var_conv : string</span>
<span class="sd">        column of Data containing total conversions for each path.</span>
<span class="sd">    var_null : string</span>
<span class="sd">        column of Data containing total paths that do not lead to conversion.</span>
<span class="sd">    order : int, default 1</span>
<span class="sd">        Markov model order.        </span>
<span class="sd">    sep : string, default &quot;&gt;&quot;</span>
<span class="sd">        separator between the channels.    </span>
<span class="sd">    flg_equal: bool, default True</span>
<span class="sd">        if True, transitions from a channel to itself will be considered.    </span>
<span class="sd">    flg_adv : bool, default True</span>
<span class="sd">        if True, ChannelAttribution Pro banner is printed.</span>
<span class="sd">                    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of DataFrames</span>
<span class="sd">        channels: Dataframe</span>
<span class="sd">            (column) id_channel : channel ids</span>
<span class="sd">            (column) channel_name : channel names</span>
<span class="sd">        transition_matrix : DataFrame</span>
<span class="sd">            (column) channel_from: id channel from</span>
<span class="sd">            (column) channel_to : id channel to</span>
<span class="sd">            (column) transition_probability : transition probability from channel_from to channel_to</span>
<span class="sd">                    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Load Data</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd    </span>
<span class="sd">    &gt;&gt;&gt; from ChannelAttribution import *</span>
<span class="sd">    &gt;&gt;&gt; Data = pd.read_csv(&#39;https://channelattribution.io/csv/Data.csv&#39;,sep=&quot;;&quot;)</span>

<span class="sd">    Estimate a second-order transition matrix using total conversions and paths that do not lead to conversion </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; transition_matrix(Data, &quot;path&quot;, &quot;total_conversions&quot;, var_null=&quot;total_null&quot;, order=2)</span>
<span class="sd">                    </span>
<span class="sd">    &#39;&#39;&#39;</span>
     
    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;DataFrame&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Data</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Data must be a DataFrame&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">var_path</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">var_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a column of Data&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a string&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">var_conv</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_conv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a column of Data&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a string&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">var_null</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_null</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_null must be a column of Data&quot;</span><span class="p">)</span>        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a string&quot;</span><span class="p">)</span>
   
      
    <span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;order must be &gt;= 1&quot;</span><span class="p">)</span>
    
        
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;sep must have length 1&quot;</span><span class="p">)</span>

            
    <span class="k">if</span> <span class="p">(</span><span class="n">flg_equal</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span> 
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;flg_equal must be False or True&quot;</span><span class="p">)</span>
                    
    <span class="n">res0</span><span class="o">=</span><span class="n">__transition_matrix_1</span><span class="p">(</span><span class="n">vy</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_path</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="n">vc</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_conv</span><span class="p">],</span><span class="n">vn</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_null</span><span class="p">],</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">),</span> <span class="n">flg_equal</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">flg_equal</span><span class="p">))</span>
    
    <span class="n">res</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;id_channel&#39;</span><span class="p">:</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;channel_name&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)})</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;transition_matrix&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;channel_from&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;channel_to&#39;</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">res0</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span><span class="s1">&#39;transition_probability&#39;</span><span class="p">:</span><span class="n">res0</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
    
    <span class="k">if</span> <span class="n">flg_adv</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** Looking to run more advanced attribution? Try ChannelAttribution Pro for free! Visit https://channelattribution.io/product&quot;</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>
    
    
    
<div class="viewcode-block" id="auto_markov_model"><a class="viewcode-back" href="../index.html#ChannelAttribution.auto_markov_model">[docs]</a><span class="k">def</span> <span class="nf">auto_markov_model</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">var_path</span><span class="p">,</span> <span class="n">var_conv</span><span class="p">,</span> <span class="n">var_null</span><span class="p">,</span> <span class="n">var_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">roc_npt</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nsim_start</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">max_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_more</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">ncore</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nfold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">conv_par</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">rate_step_sim</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flg_adv</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Data : DataFrame</span>
<span class="sd">        customer journeys.</span>
<span class="sd">    var_path: string</span>
<span class="sd">        column of Data containing paths.</span>
<span class="sd">    var_conv : string</span>
<span class="sd">        column of Data containing total conversions for each path.</span>
<span class="sd">    var_null : string</span>
<span class="sd">        column of Data containing total paths that do not lead to conversion.</span>
<span class="sd">    var_value : string, optional, default None</span>
<span class="sd">        column of Data containing revenue for each path</span>
<span class="sd">    max_order : int, default 10</span>
<span class="sd">        maximum Markov Model order to be considered.        </span>
<span class="sd">    roc_npt: int, default 100</span>
<span class="sd">        number of points to be used for the approximation of roc curve.    </span>
<span class="sd">    plot: bool, default True</span>
<span class="sd">        if True, a plot with penalized auc with respect to order will be displayed.</span>
<span class="sd">    nsim_start : int, default 1e5</span>
<span class="sd">        minimum number of simulations to be used in computation.        </span>
<span class="sd">    max_step : int, default None</span>
<span class="sd">        maximum number of steps for a single simulated path. if NULL, it is the maximum number of steps found into Data.        </span>
<span class="sd">    out_more : bool, default False</span>
<span class="sd">        if True, transition probabilities between channels and removal effects will be returned.                </span>
<span class="sd">    sep : string, default &quot;&gt;&quot;</span>
<span class="sd">        separator between the channels.    </span>
<span class="sd">    ncore : int, default 1</span>
<span class="sd">        number of threads to be used in computation.        </span>
<span class="sd">    nfold : int, default 10</span>
<span class="sd">        how many repetitions to be used to verify if convergence has been reached at each iteration.    </span>
<span class="sd">    seed : int, default 0</span>
<span class="sd">        random seed. Giving this parameter the same value over different runs guarantees that results will not vary.    </span>
<span class="sd">    conv_par : double, default 0.05</span>
<span class="sd">        convergence parameter for the algorithm. The estimation process ends when the percentage of variation of the results over different repetions is less than convergence parameter.    </span>
<span class="sd">    rate_step_sim : double, default 0</span>
<span class="sd">        number of simulations used at each iteration is equal to the number of simulations used at previous iteration multiplied by rate_step_sim.    </span>
<span class="sd">    verbose : bool, default True</span>
<span class="sd">        if True, additional information about process convergence will be shown.    </span>
<span class="sd">    flg_adv : bool, default True</span>
<span class="sd">        if True, ChannelAttribution Pro banner is printed.</span>
<span class="sd">            </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of DataFrames</span>
<span class="sd">        result: Dataframe</span>
<span class="sd">            (column) channel_name : channel names</span>
<span class="sd">            (column) total_conversions : conversions attributed to each channel</span>
<span class="sd">            (column) total_conversion_value : revenues attributed to each channel</span>
<span class="sd">        transition_matrix : DataFrame</span>
<span class="sd">            (column) channel_from: channel from</span>
<span class="sd">            (column) channel_to : channel to</span>
<span class="sd">            (column) transition_probability : transition probability from channel_from to channel_to</span>
<span class="sd">        removal_effects:</span>
<span class="sd">            (column) channel_name : channel names </span>
<span class="sd">            (column) removal_effects_conversion : removal effects for each channel calculated using total conversions</span>
<span class="sd">            (column) removal_effects_conversion_value : removal effects for each channel calculated using revenues</span>
<span class="sd">                </span>
<span class="sd">                        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Load Data</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd    </span>
<span class="sd">    &gt;&gt;&gt; from ChannelAttribution import *</span>
<span class="sd">    &gt;&gt;&gt; Data = pd.read_csv(&#39;https://channelattribution.io/csv/Data.csv&#39;,sep=&quot;;&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Estimate an automatic Makov model </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; auto_markov_model(Data, &quot;path&quot;, &quot;total_conversions&quot;, &quot;total_null&quot;)</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;DataFrame&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">Data</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Data must be a DataFrame&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">var_path</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">var_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a column of Data&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_path must be a string&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">var_conv</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_conv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a column of Data&quot;</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_conv must be a string&quot;</span><span class="p">)</span>
   
   
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">var_null</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_null</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_null must be a column of Data&quot;</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_null must be a string&quot;</span><span class="p">)</span>
   
   
    <span class="k">if</span> <span class="p">(</span><span class="n">var_value</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">var_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;var_value must be a column of Data&quot;</span><span class="p">)</span>
              
    <span class="k">if</span> <span class="p">(</span><span class="n">max_order</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;max_order must be &gt;= 1&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">roc_npt</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;roc_npt must be &gt;= 10&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">plot</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;plot must be False or True&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">nsim_start</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nsim_start</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;nsim must be &gt;= 1&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">max_step</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_step</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;max_step must be &gt;= 1&quot;</span><span class="p">)</span>
        
    
    <span class="k">if</span> <span class="p">(</span><span class="n">out_more</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;out_more must be False or True&quot;</span><span class="p">)</span>
    
        
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;sep must have length 1&quot;</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="p">(</span><span class="n">ncore</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;ncore must be &gt;= 1&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">nfold</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;nfold must be &gt;= 1&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">seed</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">seed</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;seed must be &gt;= 0&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">conv_par</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">conv_par</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;conv_par must be into [0,1]&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">rate_step_sim</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;rate_step_sim must be &gt; 0&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">verbose</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span> 
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;verbose must be False or True&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">var_value</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vv</span><span class="o">=</span><span class="n">Data</span><span class="p">[</span><span class="n">var_value</span><span class="p">]</span>
            
    <span class="p">[</span><span class="n">res_auc</span><span class="p">,</span><span class="n">res_roc</span><span class="p">,</span><span class="n">best_order</span><span class="p">]</span> <span class="o">=</span> <span class="n">choose_order</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">var_path</span><span class="p">,</span> <span class="n">var_conv</span><span class="p">,</span> <span class="n">var_null</span><span class="p">,</span> <span class="n">max_order</span> <span class="o">=</span> <span class="n">max_order</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="n">sep</span><span class="p">,</span> <span class="n">ncore</span> <span class="o">=</span> <span class="n">ncore</span><span class="p">,</span> <span class="n">roc_npt</span> <span class="o">=</span> <span class="n">roc_npt</span><span class="p">,</span> <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span> <span class="n">flg_adv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">res</span> <span class="o">=</span> <span class="n">markov_model</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">var_path</span><span class="p">,</span> <span class="n">var_conv</span><span class="p">,</span> <span class="n">var_value</span> <span class="o">=</span> <span class="n">var_value</span><span class="p">,</span> <span class="n">var_null</span> <span class="o">=</span> <span class="n">var_null</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">best_order</span><span class="p">,</span> <span class="n">nsim_start</span> <span class="o">=</span> <span class="n">nsim_start</span><span class="p">,</span> <span class="n">max_step</span> <span class="o">=</span> <span class="n">max_step</span><span class="p">,</span> <span class="n">out_more</span> <span class="o">=</span> <span class="n">out_more</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="n">sep</span><span class="p">,</span> <span class="n">ncore</span> <span class="o">=</span> <span class="n">ncore</span><span class="p">,</span> <span class="n">nfold</span> <span class="o">=</span> <span class="n">nfold</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">,</span> <span class="n">conv_par</span> <span class="o">=</span> <span class="n">conv_par</span><span class="p">,</span> <span class="n">rate_step_sim</span> <span class="o">=</span> <span class="n">rate_step_sim</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">flg_adv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">flg_adv</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** Looking to run more advanced attribution? Try ChannelAttribution Pro for free! Visit https://channelattribution.io/product&quot;</span><span class="p">)</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>
    

<span class="c1">#######################################################################################################################################################################</span>
<span class="c1">#APIS</span>
<span class="c1">#######################################################################################################################################################################</span>

<span class="c1"># if 0!=0:</span>

<span class="c1">#     def __import_libs_for_api():</span>
<span class="c1">#         global pysftp</span>
<span class="c1">#         global tarfile</span>
<span class="c1">#         global uuid</span>
<span class="c1">#         global time</span>
<span class="c1">#         global shutil</span>
<span class="c1">#         global Fernet</span>
<span class="c1">#         global json</span>
<span class="c1">#         global requests</span>
<span class="c1">#         global socket</span>
<span class="c1">#         import pysftp</span>
<span class="c1">#         import tarfile</span>
<span class="c1">#         import uuid</span>
<span class="c1">#         import time</span>
<span class="c1">#         import shutil</span>
<span class="c1">#         from cryptography.fernet import Fernet</span>
<span class="c1">#         import json</span>
<span class="c1">#         import requests</span>
<span class="c1">#         import socket</span>
        
<span class="c1">#     def __check_libs_for_api():</span>
<span class="c1">#         res=1</span>
<span class="c1">#         libs=[&#39;pysftp&#39;,&#39;tarfile&#39;,&#39;uuid&#39;,&#39;time&#39;,&#39;urllib&#39;,&#39;shutil&#39;,&#39;cryptography&#39;,&#39;json&#39;,&#39;requests&#39;]</span>
<span class="c1">#         no_libs=[]</span>
<span class="c1">#         for lib0 in libs:</span>
<span class="c1">#             ck=importlib.util.find_spec(lib0)</span>
<span class="c1">#             if ck==None:</span>
<span class="c1">#                 no_libs= no_libs+[lib0]</span>
<span class="c1">#         if len(no_libs)&gt;0:</span>
<span class="c1">#             print(&quot;There are some missing libraries you need for using our apis. Install them with:&quot;)</span>
<span class="c1">#             print(&quot;pip install &quot; + &quot; &quot;.join(no_libs))</span>
<span class="c1">#             res=0</span>
<span class="c1">#         return(res)</span>
    
<span class="c1">#     def __f_list_files(sftp):</span>
<span class="c1">#         directory_structure = sftp.listdir_attr()</span>
<span class="c1">#         vattr=[]</span>
<span class="c1">#         for attr in directory_structure:</span>
<span class="c1">#             vattr=vattr+[attr.filename]</span>
<span class="c1">#             #print(attr.filename, attr)</span>
<span class="c1">#         return(vattr)</span>
    
<span class="c1">#     def __f_save_to_crypted(data,filename,key,cipher_suite):</span>
<span class="c1">#         data=data.to_json(orient=&quot;records&quot;)</span>
<span class="c1">#         data=str.encode(data)</span>
        
<span class="c1">#         cipher_text = cipher_suite.encrypt(data)</span>
        
<span class="c1">#         f = open(filename, &quot;wb&quot;)</span>
<span class="c1">#         f.write(cipher_text)</span>
<span class="c1">#         f.close()</span>
        
<span class="c1">#         tar = tarfile.open(filename+&quot;.tar.gz&quot;, &quot;w:gz&quot;)</span>
<span class="c1">#         tar.add(filename, arcname=filename)</span>
<span class="c1">#         tar.close()</span>
        
<span class="c1">#         return(0)</span>
    
<span class="c1">#     def __f_save_to_crypted_list(list_Data,filename,key,cipher_suite):</span>
<span class="c1">#         tar = tarfile.open(filename+&quot;.tar.gz&quot;, &quot;w:gz&quot;)</span>
<span class="c1">#         for filename0 in list_Data.keys():</span>
            
<span class="c1">#             data=list_Data[filename0]</span>
            
<span class="c1">#             data=data.to_json(orient=&quot;records&quot;)</span>
<span class="c1">#             data=str.encode(data)</span>
    
<span class="c1">#             cipher_text = cipher_suite.encrypt(data)</span>
    
<span class="c1">#             f = open(filename0, &quot;wb&quot;)</span>
<span class="c1">#             f.write(cipher_text)</span>
<span class="c1">#             f.close()</span>
    
<span class="c1">#             tar.add(filename0, arcname=filename0)</span>
<span class="c1">#             os.remove(filename0)</span>
<span class="c1">#         tar.close()</span>
    
<span class="c1">#         return(0)</span>
    
<span class="c1">#     def __f_put_file(filename0,sftp,ntry=12):</span>
<span class="c1">#         z=0</span>
<span class="c1">#         flg_ok=0</span>
<span class="c1">#         list_files=[]</span>
<span class="c1">#         while (filename0 not in list_files) and (z&lt;ntry):</span>
<span class="c1">#             sftp.put(filename0, filename0)</span>
<span class="c1">#             list_files=__f_list_files(sftp)</span>
<span class="c1">#             if filename0 in list_files:</span>
<span class="c1">#                 flg_ok=1</span>
<span class="c1">#                 break</span>
<span class="c1">#             else:</span>
<span class="c1">#                 time.sleep(5)</span>
<span class="c1">#             z=z+1</span>
<span class="c1">#         if flg_ok==1:</span>
<span class="c1">#             print(&quot;Your data has been encrypted and sent to our server for the execution.&quot;)</span>
<span class="c1">#         else:</span>
<span class="c1">#             ValueError(&quot;put_file: timeout reached.&quot;)</span>
        
<span class="c1">#         return(0)</span>
    
<span class="c1">#     def __f_get_file(filename0,sftp,ntry=12):</span>
<span class="c1">#         z=0</span>
<span class="c1">#         flg_ok=0</span>
<span class="c1">#         ck_file=False</span>
<span class="c1">#         while (ck_file==False) and (z&lt;ntry):</span>
<span class="c1">#             sftp.get(filename0, filename0)</span>
<span class="c1">#             ck_file=os.path.exists(filename0)</span>
<span class="c1">#             if ck_file:</span>
<span class="c1">#                 flg_ok=1</span>
<span class="c1">#                 break</span>
<span class="c1">#             else:</span>
<span class="c1">#                 time.sleep(5)</span>
<span class="c1">#             z=z+1</span>
<span class="c1">#         if flg_ok==1:</span>
<span class="c1">#             print(&quot;Your output has been retrieved from our server.&quot;)</span>
<span class="c1">#         else:</span>
<span class="c1">#             ValueError(&quot;get_file: timeout reached.&quot;)</span>
        
<span class="c1">#         return(0)</span>
    
<span class="c1">#     def __f_initialize_connection(server,token):</span>
        
<span class="c1">#         filename = str(uuid.uuid4())</span>
<span class="c1">#         os.mkdir(filename)</span>
<span class="c1">#         os.chdir(filename)</span>
        
<span class="c1">#         url=&#39;https://{0}/api/api.php?type=pw&amp;filename={1}&amp;token={2}&#39;.format(server,filename,token)</span>
<span class="c1">#         #print(url)</span>
<span class="c1">#         info = requests.get(url)</span>
<span class="c1">#         info=info.text.split(&quot;\n&quot;)</span>
<span class="c1">#         Username=info[0]</span>
<span class="c1">#         Password=info[1][0:-1]</span>
    
<span class="c1">#         sftp=pysftp.Connection(host=socket.gethostbyname(server) , username=Username, password=Password)</span>
<span class="c1">#         sftp.cwd(&#39;/{0}&#39;.format(Username))</span>
        
<span class="c1">#         return([filename,sftp])</span>
    
<span class="c1">#     def __f_send_to_server(Data,is_list,filename,server,sftp):</span>
        
<span class="c1">#         url=&#39;https://{0}/api/max_size.php&#39;.format(server)</span>
<span class="c1">#         resp=requests.get(url)</span>
<span class="c1">#         msb=int(resp.text)</span>
        
<span class="c1">#         #filename = str(uuid.uuid4())</span>
<span class="c1">#         key = Fernet.generate_key()</span>
<span class="c1">#         cipher_suite = Fernet(key)</span>
    
<span class="c1">#         print(&quot;Encrypting your data...&quot;)</span>
    
<span class="c1">#         if is_list==False:</span>
<span class="c1">#             __f_save_to_crypted(Data,filename,key,cipher_suite)</span>
<span class="c1">#             os.remove(filename)</span>
<span class="c1">#         else:</span>
<span class="c1">#             __f_save_to_crypted_list(Data,filename,key,cipher_suite)</span>
            
<span class="c1">#         if os.path.getsize(filename+&quot;.tar.gz&quot;)&lt;(msb*1e6):</span>
<span class="c1">#             print(&quot;Sending your encrypted data to our server...&quot;)</span>
<span class="c1">#             print(&quot;filename: &quot; + filename)</span>
<span class="c1">#             print(&quot;key: &quot; + key.decode(&quot;utf-8&quot;))</span>
        
<span class="c1">#             __f_put_file(filename+&quot;.tar.gz&quot;,sftp,ntry=12)</span>
<span class="c1">#             os.remove(filename+&quot;.tar.gz&quot;)</span>
<span class="c1">#             return([key,cipher_suite])</span>
<span class="c1">#         else:</span>
<span class="c1">#             print(&quot;Your filesize exceed &quot;+ str(msb) +&quot; Mb which is the maximum size allowed&quot;)</span>
<span class="c1">#             os.remove(filename+&quot;.tar.gz&quot;)</span>
<span class="c1">#             return([-1,-1])</span>
    
<span class="c1">#     def __f_retrieve_from_server(filename,sftp):</span>
        
<span class="c1">#         print(&quot;Retrieving output...&quot;)</span>
        
<span class="c1">#         __f_get_file(filename+&quot;-O.tar.gz&quot;,sftp,ntry=100)</span>
<span class="c1">#         sftp.remove(filename+&quot;-O.tar.gz&quot;)</span>
    
<span class="c1">#         tar = tarfile.open(filename+&quot;-O.tar.gz&quot;, &quot;r:gz&quot;)</span>
<span class="c1">#         tar.extractall()</span>
<span class="c1">#         tar.close()</span>
<span class="c1">#         os.remove(filename+&quot;-O.tar.gz&quot;)</span>
        
<span class="c1">#         return(0)</span>
    
<span class="c1">#     def generate_token(email,job,company):</span>
    
<span class="c1">#         &#39;&#39;&#39;</span>
        
<span class="c1">#         You can use this function to generate a token that enables the use of our apis for making path-level attribution. An email containing your personal token will be sent to the email address indicated. </span>
        
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         email : string</span>
<span class="c1">#             a string with your business/university email at which we will send your personal token</span>
<span class="c1">#         job : string</span>
<span class="c1">#             a string describing your job</span>
<span class="c1">#         company: string</span>
<span class="c1">#             a string containing the name of your company/university</span>
                            
        
<span class="c1">#         Examples</span>
<span class="c1">#         --------</span>
        
<span class="c1">#         generate_token(&quot;mario.rossi@data.com&quot;,&quot;data scientist&quot;,&quot;data.com&quot;)</span>
        
<span class="c1">#         &#39;&#39;&#39;</span>
        
<span class="c1">#         server = &quot;api.channelattribution.net&quot;</span>
        
<span class="c1">#         try:</span>
<span class="c1">#             ck_libs=__check_libs_for_api()</span>
            
<span class="c1">#             if ck_libs==1:</span>
            
<span class="c1">#                 __import_libs_for_api()</span>
            
<span class="c1">#                 if email==None:</span>
<span class="c1">#                     raise NameError(&quot;email must be specified&quot;)</span>
                
<span class="c1">#                 if job==None:</span>
<span class="c1">#                     raise NameError(&quot;job must be specified&quot;)</span>
                    
<span class="c1">#                 if company==None:</span>
<span class="c1">#                     raise NameError(&quot;company must be specified&quot;)</span>
                
<span class="c1">#                 regex = r&#39;\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b&#39;</span>
                
<span class="c1">#                 def check(email):</span>
<span class="c1">#                     if(re.fullmatch(regex, email)):</span>
<span class="c1">#                         return(1)</span>
                        
<span class="c1">#                     else:</span>
<span class="c1">#                         return(0)</span>
                
<span class="c1">#                 if check(email)==0:</span>
<span class="c1">#                     print(&quot;Insert a valid email address&quot;)</span>
<span class="c1">#                     return(-1)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     job=re.sub(&quot;[^0-9a-zA-Z]+&quot;, &quot;_&quot;, job)</span>
<span class="c1">#                     company=re.sub(&quot;[^0-9a-zA-Z]+&quot;, &quot;_&quot;, company)</span>
                    
<span class="c1">#                 token = str(uuid.uuid4())</span>
                    
<span class="c1">#                 url=&quot;https://{0}/api/token_registration.php?mail={1}&amp;job={2}&amp;company={3}&amp;token={4}&quot;.format(server,email,job,company,token)</span>
<span class="c1">#                 resp=requests.get(url)</span>
<span class="c1">#                 resp=resp.text</span>
                
<span class="c1">#                 if resp[0]==&#39;1&#39;:</span>
<span class="c1">#                     print(&quot;Your token has been sent to your email address.&quot;)</span>
<span class="c1">#                     return(0)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     print(&quot;Token generation failed. Try again.&quot;)</span>
<span class="c1">#                     return(-1)</span>
            
<span class="c1">#         else:    </span>
<span class="c1">#             print(&quot;Your token has not been created. Try again or write to info@channelattribution.io&quot;)</span>
<span class="c1">#             return(-1)</span>
        
    
<span class="c1">#     def markov_model_local_api(token, Data,var_path, var_conv,var_value=None, var_null=None, order=1, sep=&quot;&gt;&quot;, ncore=1, conv_par_glob=0.05,</span>
<span class="c1">#     conv_par_loc=0.01,verbose=True):</span>
    
<span class="c1">#         &#39;&#39;&#39;</span>
<span class="c1">#         Through this function, you can make path-level attribution using Markov model. It requires a token that can be generated using the function &quot;generate_token&quot;. Your Data will be encrypted and sent to our server for being elaborated and the output will be returned. We will not share your Data or store it, it will be canceled at the end of the elaboration. If you prefer to make path attribution locally, you can write us at info@channelattribution.net.</span>
        
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         token : string</span>
<span class="c1">#             your personal token generated with function &quot;generate_token&quot;</span>
<span class="c1">#         Data : DataFrame</span>
<span class="c1">#             customer journeys.</span>
<span class="c1">#         var_path: string</span>
<span class="c1">#             column of Data containing paths.</span>
<span class="c1">#         var_conv : string</span>
<span class="c1">#             column of Data containing total conversions for each path.</span>
<span class="c1">#         var_value : string, default None</span>
<span class="c1">#             column of Data containing revenue for each path</span>
<span class="c1">#         var_null : string, default None</span>
<span class="c1">#             column of Data containing total paths that do not lead to conversion.</span>
<span class="c1">#         order : int, default 1</span>
<span class="c1">#             Markov Model order to be considered.</span>
<span class="c1">#         sep : string, default &quot;&gt;&quot;</span>
<span class="c1">#             separator between the channels.</span>
<span class="c1">#         ncore : int, default 1</span>
<span class="c1">#             number of threads to be used in computation.</span>
<span class="c1">#         conv_par_glob : float, default 0.05</span>
<span class="c1">#             convergence parameter for the global attribution. The estimation process ends when the percentage of variation of the results over dierent repetitions is less than conv_par_loc (this is equal to conv_par parameter of function &quot;markov_model&quot;)</span>
<span class="c1">#         conv_par_loc : float, default 0.05</span>
<span class="c1">#             convergence parameter for the local attribution. The estimation process ends when the percentage difference between global and aggregated local attribution is less than conv_par_loc</span>
<span class="c1">#         verbose : bool, default True</span>
<span class="c1">#             if True, additional information about process convergence will be shown.</span>
                
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         list</span>
<span class="c1">#             path_attribution: Dataframe</span>
<span class="c1">#                 (column) path : path.</span>
<span class="c1">#                 (column) idpath : path identification number.</span>
<span class="c1">#                 (column) channel : channel name.</span>
<span class="c1">#                 (column) weight_total_conversion : percentage of conversions associated to channel for the path considered.</span>
<span class="c1">#                 (column) weight_total_conversion_value : percentage of conversion value associated to channel for the path considered.</span>
<span class="c1">#             removal_effects: Dataframe</span>
<span class="c1">#                 (column) channel_name : channel name.</span>
<span class="c1">#                 (column) removal_effects_conversion : removal effects for conversion attribution from global attribution.</span>
<span class="c1">#                 (column) removal_effects_value : removal effects for value attribution from global attribution.</span>
<span class="c1">#             corrective_factors: list</span>
<span class="c1">#                 total conversions: Dataframe</span>
<span class="c1">#                     (column) channel : channel name</span>
<span class="c1">#                     (column) perc_corr_j : correction percentage at iteration j from the iterative matching process between global and local attribution.</span>
<span class="c1">#                 total conversion_value: Dataframe</span>
<span class="c1">#                     (column) channel : channel name</span>
<span class="c1">#                     (column) perc_corr_j : correction percentage at iteration j from the iterative matching process between global and local attribution.</span>
                            
<span class="c1">#         Examples</span>
<span class="c1">#         --------</span>
        
<span class="c1">#         Load Data</span>
        
<span class="c1">#         &gt;&gt;&gt; import pandas as pd    </span>
<span class="c1">#         &gt;&gt;&gt; from ChannelAttribution import *</span>
<span class="c1">#         &gt;&gt;&gt; Data = pd.read_csv(&#39;https://channelattribution.io/csv/Data.csv&#39;,sep=&quot;;&quot;)</span>
        
<span class="c1">#         Path level attribution </span>
        
<span class="c1">#         &gt;&gt;&gt; res=markov_model_local_api(token, Data,var_path=&quot;path&quot;, var_conv=&quot;total_conversions&quot;, \\ </span>
<span class="c1">#         &gt;&gt;&gt; var_value=&quot;total_conversion_value&quot;, var_null=&quot;total_null&quot;, order=1, sep=&quot;&gt;&quot;)</span>
        
<span class="c1">#         &#39;&#39;&#39;</span>
        
<span class="c1">#         server = &quot;api.channelattribution.net&quot;</span>
        
<span class="c1">#         try:</span>
<span class="c1">#             ck_libs=__check_libs_for_api()</span>
            
<span class="c1">#             if ck_libs==1:</span>
            
<span class="c1">#                 __import_libs_for_api()</span>
                
<span class="c1">#                 if &quot;NoneType&quot; in str(type(token)):</span>
<span class="c1">#                     raise NameError(&quot;token must be specified. Use function generate_token(email,job,company)&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;str&quot; not in str(type(token)):</span>
<span class="c1">#                         print(&quot;token must be a string&quot;)</span>
                
<span class="c1">#                 if &quot;NoneType&quot; in str(type(Data)):</span>
<span class="c1">#                     raise NameError(&quot;Data must be specified&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;DataFrame&quot; not in str(type(Data)):</span>
<span class="c1">#                          raise NameError(&quot;Data must be a DataFrame&quot;)</span>
                        
<span class="c1">#                 if &quot;NoneType&quot; in str(type(var_path)):</span>
<span class="c1">#                     raise NameError(&quot;var_path must be specified&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;str&quot; not in str(type(var_path)):</span>
<span class="c1">#                         print(&quot;var_path must be a string&quot;)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         var_path_old=var_path</span>
<span class="c1">#                         var_path=re.sub(r&quot;\s+&quot;, &#39;_&#39;, var_path)</span>
<span class="c1">#                         Data.rename(columns={var_path_old: var_path},inplace=True)</span>
                
<span class="c1">#                 if &quot;NoneType&quot; in str(type(var_conv)):</span>
<span class="c1">#                     raise NameError(&quot;var_conv must be specified&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;str&quot; not in str(type(var_conv)):</span>
<span class="c1">#                         print(&quot;var_conv must be a string&quot;)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         var_conv_old=var_conv</span>
<span class="c1">#                         var_conv=re.sub(r&quot;\s+&quot;, &#39;_&#39;, var_conv)</span>
<span class="c1">#                         Data.rename(columns={var_conv_old: var_conv},inplace=True)</span>
                
<span class="c1">#                 if &quot;NoneType&quot; not in str(type(var_value)):</span>
<span class="c1">#                     var_value=re.sub(r&quot;\s+&quot;, &#39;_&#39;, var_value)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;str&quot; not in str(type(var_value)):</span>
<span class="c1">#                         print(&quot;var_value must be a string&quot;)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         var_value_old=var_value</span>
<span class="c1">#                         var_value=re.sub(r&quot;\s+&quot;, &#39;_&#39;, var_value)</span>
<span class="c1">#                         Data.rename(columns={var_value_old: var_value},inplace=True)</span>
                        
<span class="c1">#                 if &quot;NoneType&quot; not in str(type(var_null)):</span>
<span class="c1">#                     var_null=re.sub(r&quot;\s+&quot;, &#39;_&#39;, var_null)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;str&quot; not in type(var_null):</span>
<span class="c1">#                         print(&quot;var_null must be a string&quot;)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         var_null_old=var_null</span>
<span class="c1">#                         var_null=re.sub(r&quot;\s+&quot;, &#39;_&#39;, var_null)</span>
<span class="c1">#                         Data.rename(columns={var_null_old: var_null},inplace=True)</span>
                    
<span class="c1">#                 if &quot;NoneType&quot; not in str(type(order)):</span>
<span class="c1">#                     if &quot;int&quot; not in str(type(order)):</span>
<span class="c1">#                         print(&quot;order must be a int&quot;)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         if order&lt;1:</span>
<span class="c1">#                             print(&quot;order must be &gt; 0&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     print(&quot;order must be specified&quot;)</span>
                    
<span class="c1">#                 if &quot;NoneType&quot; not in str(type(sep)):</span>
<span class="c1">#                     if &quot;str&quot; not in str(type(sep)):</span>
<span class="c1">#                         print(&quot;sep must be a string&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     print(&quot;sep must be specified&quot;)</span>
                    
<span class="c1">#                 if &quot;NoneType&quot; not in str(type(conv_par_glob)):</span>
<span class="c1">#                     if &quot;float&quot; not in str(type(conv_par_glob)):</span>
<span class="c1">#                         print(&quot;conv_par_glob must be a float&quot;)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         if conv_par_glob&lt;=0:</span>
<span class="c1">#                             print(&quot;conv_par_glob must be &gt; 0&quot;)</span>
                            
<span class="c1">#                 if &quot;NoneType&quot; not in str(type(conv_par_loc)):</span>
<span class="c1">#                     if &quot;float&quot; not in str(type(conv_par_loc)):</span>
<span class="c1">#                         print(&quot;conv_par_loc must be a float&quot;)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         if conv_par_loc&lt;=0:</span>
<span class="c1">#                             print(&quot;conv_par_loc must be &gt; 0&quot;)</span>
                            
<span class="c1">#                 if &quot;NoneType&quot; not in str(type(verbose)):</span>
<span class="c1">#                     if &quot;bool&quot; not in str(type(verbose)):</span>
<span class="c1">#                         print(&quot;verbose must be True or False&quot;)</span>
                        
                
<span class="c1">#                 path0=os.getcwd()</span>
                
<span class="c1">#                 #initialize connection</span>
                
<span class="c1">#                 [filename,sftp]=__f_initialize_connection(server,token)</span>
                
<span class="c1">#                 #send input to server</span>
                
<span class="c1">#                 [key,cipher_suite]=__f_send_to_server(Data,False,filename,server,sftp)</span>
                
<span class="c1">#                 if key!=-1:</span>
<span class="c1">#                     #elaborate on server</span>
                    
<span class="c1">#                     print(&quot;Asking to our server to start the elaboration...&quot;)</span>
<span class="c1">#                     url=&#39;https://{0}/api/api.php?type=markov-model-local&amp;filename={1}&amp;key={2}&amp;var_path={3}&amp;var_conv={4}&amp;var_value={5}&amp;var_null={6}&amp;order={7}&amp;sep={8}&amp;ncore={9}&amp;conv_par_glob={10}&amp;conv_par_loc={11}&amp;verbose={12}&amp;token={13}&#39;.format(server,filename,key.decode(&quot;utf-8&quot;),var_path,var_conv,var_value,var_null,order,sep,ncore,conv_par_glob,conv_par_loc,verbose,token)</span>
<span class="c1">#                     #print(url)</span>
<span class="c1">#                     resp=requests.get(url)</span>
<span class="c1">#                     resp=resp.text</span>
<span class="c1">#                     print(resp)</span>
                    
<span class="c1">#                     if &quot;token_ko&quot; not in resp:</span>
<span class="c1">#                         &#39;&#39;&#39;&#39;</span>
<span class="c1">#                           cipher_suite = Fernet(str.encode(key))</span>
<span class="c1">#                         &#39;&#39;&#39;</span>
<span class="c1">#                         #retrieving output</span>
                        
<span class="c1">#                         __f_retrieve_from_server(filename,sftp)</span>
                        
<span class="c1">#                         print(&quot;Composing output...&quot;)</span>
                        
<span class="c1">#                         res=dict()</span>
<span class="c1">#                         for elem in [&#39;path_attribution&#39;,&#39;removal_effects&#39;,&#39;corrective_factors&#39;]:</span>
<span class="c1">#                             cipher_text = open(elem, &#39;r&#39;).read()</span>
<span class="c1">#                             plain_text = cipher_suite.decrypt(str.encode(cipher_text),)</span>
<span class="c1">#                             res[elem]=pd.read_json(plain_text,orient=&#39;records&#39;)</span>
                            
<span class="c1">#                         tmp=res[&#39;corrective_factors&#39;].copy()</span>
<span class="c1">#                         tmp1=tmp[tmp.type==&#39;total_conversions&#39;]</span>
<span class="c1">#                         del tmp1[&#39;type&#39;]</span>
<span class="c1">#                         tmp2=tmp[tmp.type==&#39;total_conversion_value&#39;]</span>
<span class="c1">#                         del tmp2[&#39;type&#39;]</span>
                        
<span class="c1">#                         res[&#39;corrective_factors&#39;]=dict()</span>
<span class="c1">#                         res[&#39;corrective_factors&#39;][&#39;total_conversions&#39;]=tmp1 </span>
<span class="c1">#                         res[&#39;corrective_factors&#39;][&#39;total_conversion_value&#39;]=tmp2 </span>
                        
<span class="c1">#                         shutil.rmtree(path0+&#39;/&#39;+filename)</span>
<span class="c1">#                         os.chdir(path0)</span>
                        
<span class="c1">#                         print(&quot;Your data has been cancelled from our server&quot;)</span>
<span class="c1">#                         print(&quot;Elaboration finished!&quot;)</span>
                        
<span class="c1">#                         return(res)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         print(&quot;Your token is not valid. Try again or try to generate a new one.&quot;)</span>
<span class="c1">#                         return(-1)</span>
                    
<span class="c1">#                 else:</span>
<span class="c1">#                     return(-1)</span>
                
<span class="c1">#             else:</span>
<span class="c1">#                 return(-1)</span>
            
<span class="c1">#         except:</span>
<span class="c1">#             url=&#39;https://{0}/api/remove_data.php?filename={1}&#39;.format(server,filename)</span>
<span class="c1">#             resp=requests.get(url)</span>
<span class="c1">#             print(&quot;Your data has been cancelled from our server&quot;)</span>
<span class="c1">#             print(&quot;Elaboration interrupted with errors. Try again or write to info@channelattribution.io&quot;)</span>
<span class="c1">#             return(-1)</span>
<span class="c1">#             #raise</span>
        
<span class="c1">#     def new_paths_attribution_api(token, tab_new,var_path,Tab_re,D_tab_corr,sep=&quot;&gt;&quot;):</span>
    
<span class="c1">#         &#39;&#39;&#39;</span>
        
<span class="c1">#         Through this function, you can make path-level attribution using Markov model on paths you have not observed before. This function can be also used in real-time attribution. It requires a token that can be generated using the function &quot;generate_token&quot;. Your Data will be encrypted and sent to our server for being elaborated and the output will be returned. We will not share your Data or store it, it will be canceled at the end of the elaboration. If you prefer to make path attribution locally, you can write us at info@channelattribution.io.</span>
        
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         token : string</span>
<span class="c1">#             your personal token generated with generate_token function.</span>
<span class="c1">#         tab_new : DataFrame containing new paths for which you want to make path level attribution.</span>
<span class="c1">#             paths</span>
<span class="c1">#         var_path: string</span>
<span class="c1">#             column of tab_new containing paths.</span>
<span class="c1">#         Tab_re : DataFrame</span>
<span class="c1">#             removal effects from global attribution.</span>
<span class="c1">#         D_tab_corr : list of DataFrames</span>
<span class="c1">#             corrective factors from local attribution.</span>
<span class="c1">#         sep : string, default &quot;&gt;&quot;</span>
<span class="c1">#             separator between the channels.</span>
    
                
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         DataFrame</span>
<span class="c1">#             result: Dataframe</span>
<span class="c1">#                 (column) path : path.</span>
<span class="c1">#                 (column) idpath : path identification number.</span>
<span class="c1">#                 (column) channel : channel name.</span>
<span class="c1">#                 (column) weight_total_conversion : percentage of conversions associated to channel for the path considered.</span>
<span class="c1">#                 (column) weight_total_conversion_value : percentage of conversion value associated to channel for the path considered.</span>
                            
<span class="c1">#         Examples</span>
<span class="c1">#         --------</span>
        
<span class="c1">#         Load Data</span>
        
<span class="c1">#         &gt;&gt;&gt; import pandas as pd    </span>
<span class="c1">#         &gt;&gt;&gt; from ChannelAttribution import *</span>
<span class="c1">#         &gt;&gt;&gt; Data = pd.read_csv(&#39;https://channelattribution.io/csv/Data.csv&#39;,sep=&quot;;&quot;)</span>
        
<span class="c1">#         Path level attribution </span>
        
<span class="c1">#         &gt;&gt;&gt; res=markov_model_local_api(token, Data,var_path=&quot;path&quot;, var_conv=&quot;total_conversions&quot;, \\</span>
<span class="c1">#         &gt;&gt;&gt; var_value=&quot;total_conversion_value&quot;, var_null=&quot;total_null&quot;, order=1, sep=&quot;&gt;&quot;)</span>
        
<span class="c1">#         Path level attribution on new paths</span>
        
<span class="c1">#         &gt;&gt;&gt; res_new=new_paths_attribution_api(token, tab_new,var_path=&quot;path&quot;, \\ </span>
<span class="c1">#         &gt;&gt;&gt; Tab_re=res[&#39;removal_effects&#39;],D_tab_corr=res[&#39;corrective_factors&#39;],sep=&quot;&gt;&quot;)</span>
        
<span class="c1">#         &#39;&#39;&#39;</span>
        
<span class="c1">#         server = &quot;api.channelattribution.net&quot;</span>
    
<span class="c1">#         try:</span>
<span class="c1">#             ck_libs=__check_libs_for_api()</span>
            
<span class="c1">#             if ck_libs==1:</span>
            
<span class="c1">#                 __import_libs_for_api()</span>
            
<span class="c1">#                 if &quot;NoneType&quot; in str(type(token)):</span>
<span class="c1">#                     raise NameError(&quot;token must be specified. Use function generate_token(email,job,company)&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;str&quot; not in str(type(token)):</span>
<span class="c1">#                         print(&quot;token must be a string&quot;)</span>
                
<span class="c1">#                 if &quot;NoneType&quot; in str(type(tab_new)):</span>
<span class="c1">#                     raise NameError(&quot;tab_new must be specified&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;DataFrame&quot; not in str(type(tab_new)):</span>
<span class="c1">#                          raise NameError(&quot;tab_new must be a DataFrame&quot;)</span>
                        
<span class="c1">#                 if &quot;NoneType&quot; in str(type(var_path)):</span>
<span class="c1">#                     raise NameError(&quot;var_path must be specified&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;str&quot; not in str(type(var_path)):</span>
<span class="c1">#                         print(&quot;var_path must be a string&quot;)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         var_path_old=var_path</span>
<span class="c1">#                         var_path=re.sub(r&quot;\s+&quot;, &#39;_&#39;, var_path)</span>
<span class="c1">#                         tab_new.rename(columns={var_path_old: var_path},inplace=True)</span>
                
<span class="c1">#                 if &quot;NoneType&quot; in str(type(Tab_re)):</span>
<span class="c1">#                     raise NameError(&quot;Tab_re must be specified&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;DataFrame&quot; not in str(type(Tab_re)):</span>
<span class="c1">#                          raise NameError(&quot;Tab_re must be a DataFrame&quot;)</span>
                
<span class="c1">#                 if &quot;NoneType&quot; in str(type(D_tab_corr)):</span>
<span class="c1">#                     raise NameError(&quot;D_tab_corr must be specified&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if &quot;dict&quot; not in str(type(D_tab_corr)):</span>
<span class="c1">#                          raise NameError(&quot;D_tab_corr must be a dictionary&quot;)</span>
                
<span class="c1">#                 if &quot;NoneType&quot; not in str(type(sep)):</span>
<span class="c1">#                     if &quot;str&quot; not in str(type(sep)):</span>
<span class="c1">#                         print(&quot;sep must be a string&quot;)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     print(&quot;sep must be specified&quot;)</span>
                    
                
<span class="c1">#                 path0=os.getcwd()</span>
                
<span class="c1">#                 #initialize connection</span>
                
<span class="c1">#                 [filename,sftp]=__f_initialize_connection(server,token)</span>
                
<span class="c1">#                 #send input to server</span>
                
<span class="c1">#                 list_Data=dict()</span>
<span class="c1">#                 list_Data[&#39;tab_new&#39;]=tab_new</span>
<span class="c1">#                 list_Data[&#39;Tab_re&#39;]=Tab_re</span>
<span class="c1">#                 list_Data[&#39;D_tab_corr_conv&#39;]=D_tab_corr[&#39;total_conversions&#39;]</span>
<span class="c1">#                 list_Data[&#39;D_tab_corr_value&#39;]=D_tab_corr[&#39;total_conversion_value&#39;]</span>
                
<span class="c1">#                 [key,cipher_suite]=__f_send_to_server(list_Data,True,filename,server,sftp)</span>
                
<span class="c1">#                 if key!=-1:</span>
<span class="c1">#                     # #elaborate on server</span>
                    
<span class="c1">#                     print(&quot;Asking to our server to start the elaboration...&quot;)</span>
<span class="c1">#                     url=&#39;https://{0}/api/api.php?type=new-paths-attribution&amp;filename={1}&amp;key={2}&amp;var_path={3}&amp;sep={4}&amp;token={5}&#39;.format(server,filename,key.decode(&quot;utf-8&quot;),var_path,sep,token)</span>
<span class="c1">#                     #print(url)</span>
<span class="c1">#                     resp=requests.get(url)</span>
<span class="c1">#                     resp=resp.text</span>
<span class="c1">#                     print(resp)</span>
                    
<span class="c1">#                     if &quot;token_ko&quot; not in resp:</span>
                        
<span class="c1">#                         #retrieving output</span>
                        
<span class="c1">#                         __f_retrieve_from_server(filename,sftp)</span>
                        
<span class="c1">#                         print(&quot;Composing output...&quot;)</span>
                        
<span class="c1">#                         cipher_text = open(filename+&#39;-O&#39;, &#39;r&#39;).read()</span>
<span class="c1">#                         plain_text = cipher_suite.decrypt(str.encode(cipher_text))</span>
<span class="c1">#                         res=pd.read_json(plain_text,orient=&#39;records&#39;)</span>
                        
<span class="c1">#                         shutil.rmtree(path0+&#39;/&#39;+filename)</span>
<span class="c1">#                         os.chdir(path0)</span>
                        
<span class="c1">#                         print(&quot;Your data has been cancelled from our server&quot;)</span>
<span class="c1">#                         print(&quot;Elaboration finished!&quot;) </span>
                        
<span class="c1">#                         return(res)</span>
                    
<span class="c1">#                     else:</span>
<span class="c1">#                         print(&quot;Your token is not valid. Try again or try to generate a new one.&quot;)</span>
<span class="c1">#                         return(-1)</span>
                
<span class="c1">#                 else:</span>
<span class="c1">#                     return(-1)</span>
            
<span class="c1">#         except:</span>
<span class="c1">#             url=&#39;https://{0}/api/remove_data.php?filename={1}&#39;.format(server,filename)</span>
<span class="c1">#             resp=requests.get(url)</span>
<span class="c1">#             print(&quot;Your data has been cancelled from our server&quot;)</span>
<span class="c1">#             print(&quot;Elaboration interrupted with errors. Try again or write to info@channelattribution.io&quot;)</span>
<span class="c1">#             return(-1)</span>
            
            
    
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ChannelAttribution 2.1.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ChannelAttribution</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright Davide Altomare and David Loris.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.1.
    </div>
  </body>
</html>